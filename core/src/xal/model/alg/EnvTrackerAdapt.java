/*
 * EnvTrackerAdapt.java
 *
 *  Created on November 21, 2003, 11:14 AM
 *  Modified:
 *      12/02   - CKA
 *      9/03    - CKA: added space charge interval prediction
 *                   : added rotation into ellipsoid coordinates
 *      11/03   - CKA: full-second order adaptive step size
 *      11/03   - CKA: choice of integration accuracy order
 */

package xal.model.alg;


import xal.model.IElement;
import xal.model.IProbe;
import xal.model.ModelException;
import xal.model.elem.IdealDrift;
import xal.model.elem.IdealRfGap;
import xal.model.elem.ThinElement;
import xal.model.probe.EnvelopeProbe;
import xal.model.probe.traj.EnvelopeProbeState;
import xal.model.probe.traj.ProbeState;
import xal.tools.beam.CovarianceMatrix;
import xal.tools.beam.PhaseMap;
import xal.tools.beam.PhaseMatrix;
import xal.tools.beam.Twiss;
import xal.tools.data.DataAdaptor;
import xal.tools.data.DataFormatException;
import xal.tools.data.DataTable;
import xal.tools.data.EditContext;
import xal.tools.data.GenericRecord;

/**
 * <p>
 * Tracking algorithm for <code>EnvelopeProbe</code>'s.  The <code>EnvelopeProbe</code>'s
 * state, which is a <code>CovarianceMatrix</code> object, is advanced using the linear
 * dynamics portion of any beamline element (<code>IElement</code> exposing object) transfer
 * map.  The linear portion is represented as a matrix, thus, the state advance is accomplished
 * with a transpose conjugation with this matrix.
 * </p>
 * <p>
 * The effects of space charge are also included in the dynamics calculations.  Space charge
 * effects are also represented with a matrix transpose conjugation, however, the matrix is
 * computed using the values of the probe's correlation matrix.  The result is a nonlinear
 * effect.  The space charge forces are computed using a linear fit to the fields generated by
 * an ellipsoidal charge distribution with the same statistics described in the probe's 
 * correlation matrix.  The linear fit is weighted by the beam distribution itself, so it is 
 * more accurate in regions of higher charged density.  For a complete description see the reference
 * below.
 * </p>
 * <p>
 * This algorithm uses a second-order accurate, adaptive step sizing algorithm where the step
 * size is continually adjusted to maintain an given error tolerance in the residual.
 * </p> 
 *
 * @see xal.tools.beam.em.BeamEllipsoid
 * @see <a href="http://lib-www.lanl.gov/cgi-bin/getfile?00796950.pdf">Theory and Technique
 *      of Beam Envelope Simulation</a>
 *
 * @author Christopher K. Allen
 */
public class EnvTrackerAdapt extends EnvelopeTrackerBase {



    // Archiving constants 
    
    /** EditContext label for table containing adaptive tracker parameters   */
    private static final String TBL_LBL_ENVTRACKERADAPT = "EnvTrackerAdapt";
    
    /** attribute label for maximum step size */
    private final static String      ATTRTAG_MAXSTEP = "maxstep";
    
    /** attribute label for maximum step size for drift space with pmq , sako 21 jul 06 */
    private final static String      ATTRTAG_MAXSTEP_DRIFTPMQ = "maxstepdriftpmq";
    
    /** attribute label for initial step size */
    private final static String      ATTRTAG_INITSTEP= "initstep";
    
    /** attribute label for error tolerance */
    private final static String      ATTRTAG_ERRTOL  = "errortol"; 
    
    /** attribute label for slack tolerance */
    private final static String      ATTRTAG_SLACK   = "slack";
    
    /** attribute label for residual norm */
    private final static String      ATTRTAG_NORM    = "norm";
    
    /** attribute label for maximum iteration count */
    private final static String      ATTRTAG_MAXITER = "maxiter";
    
    /** data node label for EnvTrackerAdapt settings */
    private final static String      NODETAG_ADAPT   = "adapt";
    
    /** attribute label for order of accuracy in algorithm */
    private final static String      ATTRTAG_ORDER   = "order";
    
    /*
     * Global Constants
     */
    
    // Lebesgue Norm Enumerations

    /** l-infinity norm */
    public static final int     NORM_LINF = 0;
    
    /** l-1 norm */
    public static final int     NORM_L1 = 1;
     
    /** l-2 norm */
    public static final int     NORM_L2 = 2;
    
    
    
    // Integration accuracy order
    
    /** Error condition in integration accuracy */
    public static final int     ACCUR_ERROR  = 0;
    
    /** 1st order accurate integration algorithm */
    public static final int     ACCUR_ORDER1 = 1;
    
    /** 2nd order accurate integration algorithm */
    public static final int     ACCUR_ORDER2 = 2; 
    
    /** Range of avaible integration accuracies */
    public static final int     ACCUR_RANGE  = 3;
    
    
     

    // IAlgorithm Parameters
        
    /** string type identifier for algorithm */
    public static final String      s_strTypeId = EnvTrackerAdapt.class.getName();
    
    /** current algorithm version */
    public static final int         s_intVersion = 2;
    
    /** probe type recognized by this algorithm */
    public static final Class<EnvelopeProbe>       s_clsProbeType = EnvelopeProbe.class;

    
    /**
     * The initial step size to start the algorithm. 
     */
    private double dlbStepSizeInit;
    
    /** 
     * The current step size. 
     */
    private double m_dblStepSize;
    
    /** 
     * Maximum distance we may travel before requiring another space charge kick.
     *  If zero than stepping distance is not bound. 
     */
    private double m_dblMaxStep;
    
    /** m_dbleMaxStep for drift field from PMQ */
    private double m_dblMaxStepDriftPmq;       
    
    /**
     * Residual error tolerance parameter.  Errors in the the residual between
     * a full step and half step can be no larger than this.
     */
    private double m_dblErrTol;
    
    /**
     * Step size adjustment slack tolerance.  If adjustments in the step size
     * are less than this percentage, we take special action.
     */
    private double m_dblSlack;
    
    /**
     * The type of Lebesque norm used in the residual calculations.  Since the 
     * residual is a matrix in R7x7 this is a matrix norm.
     */
    private int m_enmNorm;
    
    /**
     * The maximum number of iterations through an element before the algorithm
     * aborts propagation.  If the iteration count goes beyond the maximum it
     * is assumed that a race condition has occurred.
     * If zero, then there is no maximum iteration count enforced. 
     */
    private int  m_intMaxIter;
	
    /** The order of accuracy used in the integration algorithm */
    private int m_intOrder;

    /**  total number of steps taken by algorithm */
    private int m_nDbgSteps;                      
    
    
    
    
    
    /*
     *  Initialization
     */

    /** 
     *  Creates a new, uninitialized instance of <code>EnvTrackerAdapt</code> 
     */
    public EnvTrackerAdapt() { 
        super(s_strTypeId, s_intVersion, s_clsProbeType);
		m_intMaxIter = 50;
		m_intOrder = EnvTrackerAdapt.ACCUR_ORDER2;
		m_nDbgSteps = 0;
		
    }
    
    /**
     * Copy constructor for EnvTrackerAdapt
     *
     * @param       sourceTracker   Tracker that is being copied
     */
    public EnvTrackerAdapt(EnvTrackerAdapt sourceTracker) {
        super(sourceTracker);
        
        this.m_intMaxIter = sourceTracker.m_intMaxIter;
        this.m_intOrder = sourceTracker.m_intOrder;
        this.m_nDbgSteps = sourceTracker.m_nDbgSteps;
        this.dlbStepSizeInit = sourceTracker.dlbStepSizeInit;
        this.m_dblStepSize = sourceTracker.m_dblStepSize;
        this.m_dblMaxStep = sourceTracker.m_dblMaxStep;
        this.m_dblMaxStepDriftPmq = sourceTracker.m_dblMaxStepDriftPmq;
        this.m_dblErrTol = sourceTracker.m_dblErrTol;
        this.m_dblSlack = sourceTracker.m_dblSlack;
        this.m_enmNorm = sourceTracker.m_enmNorm;
    }
    
    /**
     * Creates a deep copy of EnvTrackerAdapt
     */
    @Override
    public EnvTrackerAdapt copy() {
        return new EnvTrackerAdapt( this );
    }
    
//    /**
//     * Creates a new instance of <code>EnvTrackerAdapt</code> and initializes
//     * it to the data in the global XAL EditContext object accessible through
//     * the <code>AcceleratorSeq</code> argument.
//     * 
//     * @param   seqInitializer    sequence to initialize algorithm data
//     */
//    public EnvTrackerAdapt(AcceleratorSeq seqInitializer)   {
//        this();
//        
//        // If locationID is null then take the sequence entrance identifier
//        String strPrimKeyVal = seqInitializer.getEntranceID();
//
//        // Get the algorithm class name from the EditContext
//        EditContext   ecXalGlobal = seqInitializer.getAccelerator().editContext();
//        
//        this.load(strPrimKeyVal, ecXalGlobal);
//    }
//	
//	
//	/**
//	 * Primary Constructor
//	 */
//	public EnvTrackerAdapt( final String locationID, final AcceleratorSeq sequence ) {
//        super( s_strTypeId, s_intVersion, s_clsProbeType, locationID, sequence );
//	}
//	
//	
//	/**
//	 * Constructor
//	 */
//	public EnvTrackerAdapt( final AcceleratorSeq sequence ) {
//		this ( null, sequence );
//	}
//    
    

    
    
    /**
     * Initialize the algorithm object for propagation.
     * 
     * Internal state of algorithm object is initialized:
     * - Step size is set to initial step size
     * - Start/Stop elements are inspected
     */
    @Override
    public void initialize() {
        super.initialize();
//        if (dlbStepSizeInit > 0.)
        this.setStepSize(this.getInitStepSize());
    }

//    /**
//	 * Determine whether this algorithm supports the optional accuracy odrer and maximum iteration methods.
//	 * @return true if the optional methods are supported and false if not.
//	 */
//	public boolean supportsConditionalTermination() {
//		return true;
//	}    
    
    
    
    /**
     * Set the initial step size for applying space charge
     * corrections.  Note that the step size will be modified
     * as the algorithm progresses according to the adaptation
     * rule.
     * 
     * The current step size is reset to this value anytime the
     * <code>initialize()</code> method is called.
     * 
     * @param dblStepSize   initial step size in <b>meters</b>
     * 
     * @see EnvTrackerAdapt#setInitStepSize(double)
     * @see EnvTrackerAdapt#initialize()
     */
    public void setInitStepSize(double dblStepSize){
        dlbStepSizeInit = dblStepSize;
    }

    
    /**
     * Set the current step size for applying space charge
     * corrections.  Note that the step size will be modified
     * as the algorithm progresses according to the adaptation
     * rule.
     * 
     * @param dblStepSize   initial step size in <b>meters</b>
     */
    public void setStepSize( final double dblStepSize ) {
        m_dblStepSize = dblStepSize;
    }
        
    /**
     * Set the maximum allowable step size.  If this value is
     * set then the step sizing algorithm will never generate
     * steps larger than the provided value regardless of the 
     * residual error.  If this value is
     * cleared to zero, then the step size is unbound.
     * 
     * @param dblMaxStep    maximum allowable step size in <b>meters</b>
     */
    public void setMaxStepSize( final double dblMaxStep )   {
        m_dblMaxStep = dblMaxStep;
    }
    
    /**
     * Set the maximum allowable step size.  If this value is
     * set then the step sizing algorithm will never generate
     * steps larger than the provided value regardless of the 
     * residual error.  If this value is
     * cleared to zero, then the step size is unbound.
     * 
     * @param dblMaxStepDriftPmq    maximum allowable step size in <b>meters</b>
     */
    public void setMaxStepSizeDriftPmq( final double dblMaxStepDriftPmq )   {
        m_dblMaxStepDriftPmq = dblMaxStepDriftPmq;
    }
    
    
    /**
     * Sets the maximum allowable number of steps to progate a probe through
     * an element.  If the number of steps increases beyond this number a
     * race condition is assumed and an exception is thrown during the 
     * propagation.
     * 
     * If the value is zero then no maximum step count is enforced.
     * 
     * @param   intMaxIter maximum alllowable single-element step count 
     */
    public void setMaxIterations(int intMaxIter)  {
        this.m_intMaxIter = intMaxIter;
    }
    
    
    /**
     * Set the acceptable error in the residual correlation matrix.
     * The residual correlation matrix is determined by going a full
     * step, then two half step and taking the difference in the 
     * resulting correlation matrices.  
     * 
     * The step size is continually adjusted to keep the resulting
     * residual error at or about this given tolerance value.  Thus,
     * yeild a more accurate solution however they also result in small 
     * step sizes.
     *  
     * @param dblErr    acceptable residual error
     */
    public void setErrorTolerance( final double dblErr )   {
        m_dblErrTol = dblErr;
    }
    
    /**
     * Set the integration accuracy order for the underlying
     * stepping algorithm.  For example, when using a second-order
     * accurate algorithm the residual error is of the order
     * <i>h</i>^2 where <i>h</i> is the step size.
     * 
     * @param intOrder      integration order
     */
    public void setAccuracyOrder(int intOrder)   {
        if (intOrder >= ACCUR_RANGE || intOrder <= ACCUR_ERROR)
            return;
            
        this.m_intOrder = intOrder;
    }
    
    
    /**
    * Set the slack size in the adaptive step size determination.  That is,
     * if the suggested new step size differs only by this percentage, then
     * no action is taken.  Explicitly, if the new step size lies in the 
     * interval [h-dblSlack, h+dblSlack], then nothing is done.
     * 
     * This feature prevents excessive micro-management 
     * of the step size.
     * 
     * @param dblSlack  size of the slack region in <b>meters</b>  
     */
    public void setSlackTolerance( final double dblSlack )   {
        m_dblSlack = dblSlack;
    }
    
    
    /**
     * Set the type of Lebesque norm used in the matrix calculations.  
     * 
     * @param   enmNorm     enumeration constant of family <code>EnvTrackerAdapt.NORM_*</code>
     */
    public void setMatrixNorm( final int enmNorm )    {
        if (enmNorm <0 || enmNorm > 2) 
            return;
        
        m_enmNorm = enmNorm;
    }
    
    
    /*
     * Accessing
     */
    
    /**
     * Return the initial step size for this algorithm.  This is the
     * step size when beginning a propagation.  Note that the atual
     * step size used afterwards will likely change due to the adaptive
     * nature of the algorithm.
     * 
     * @return  initial step size in <b>meters</b>
     */
    //sako, 21 jul 07
    public double getInitStepSize()  {
        return this.dlbStepSizeInit;
    }
    
    /**
     * Return the current step size, that is, the step size currently
     * used in the propagation.
     *   
     * @return  the current step size in <b>meters</b>
     */
    public double getStepSize() {
        return m_dblStepSize;
    }
    
    
    /**
     * Return the maximum allowable number of steps to progate a probe through
     * an element.  If the number of steps increases beyond this number a
     * race condition is assumed and an exception is thrown during the 
     * propagation.
     * 
     * If the value is zero then no maximum step count is enforced.
     * 
     * @return  maximum alllowable step count while propagating thru a single element
     */
    public int  getMaxIterations()  {
        return this.m_intMaxIter;
    }
    
    /**
     * Return the maximum allowable step size.  The step sizing aglorithm
     * is bound by this value, or unbounded if zero.
     * 
     * @return  maximum allowable step size in <b>meters</b>
     */
    public double getMaxStepSize()  {
        return this.m_dblMaxStep;
    }
    
    /**
     * Return the maximum allowable step size.  The step sizing aglorithm
     * is bound by this value, or unbounded if zero.
     * 
     * @return  maximum allowable step size in <b>meters</b>
     */
    public double getMaxStepSizeDriftPmq()  {
        return this.m_dblMaxStepDriftPmq;
    }
    
    /**
     * Get the current accuracy order of the space charge stepping
     * algorithm. 
     *  
     * @return      order of the integration algorithm accuracy
     * 
     * @see #setAccuracyOrder 
     */
    public int  getAccuracyOrder()   {
        return this.m_intOrder;
    }

    
    
    /**
     * Return the acceptable tolerance in the residual error between
     * a full step and two half steps.
     *  
     * @return  tolerable residual error
     */
    public double getErrorTolerance()   {
        return m_dblErrTol;    
    }
    
    
    /**
     * Step size adjustment slack tolerance.  If adjustments in the step size
     * are less than this percentage, we do nothing.
     * 
     * @return      size of the slack region in <b>meters</b>
     */
    public double getSlackTolerance()   {
        return m_dblSlack;
    }
    
    
    /**
     * Get the type of Lebesque norm used for matrices.  
     * 
     * @return  0 for l-inf norm, 1 for l-1 norm, 2 for l2 norm
     */
    public int  getMatrixNorm()       {
        return m_enmNorm;
    }
    
    
    

    /*
     *  Tracker Abstract Protocol
     */
    
    /**
     * Propagates the probe through the element using a second-order accurate
     * adaptive step size algorithm for space charge calculations.
     * 
     * The new probe state is first computed by taken a full step with the second-
     * order accurate transfer matrix with includes space charge effect.  The algorithm
     * then computes the new probe state by taking two half-steps. The residual
     * error (correlation matrix) between the two states is computed.  If the norm of 
     * the matrix is below the error tolerance (@see #getErrorTolerance) the step may
     * be lengthened.  If the residual error is greater than tolerance the step size
     * must be shortened and the new probe state recomputed.
     *
     *  @param  ifcProbe   probe to propagate
     *  @param  elem    element acting on probe
     *
     *  @exception  ModelException  invalid probe type or error in advancing probe
     */
    @Override
    public void doPropagation(IProbe ifcProbe, IElement elem) throws ModelException {
        //sako
//        setDebugMode(false);
        
        // Identify probe
        if ( !(ifcProbe instanceof EnvelopeProbe) )
            throw new IllegalArgumentException("Must be of type " + EnvelopeProbe.class.getName());

        EnvelopeProbe   probe = (EnvelopeProbe)ifcProbe;


        // If this is a thin element, no space charge calculations are necessary
        if (elem instanceof ThinElement)    {
            this.stepThinElement(probe, elem);
            return;
        }


        // Initialize the 2nd order accurate, adaptive step size algorithm
        int         iCurCnt = 0;                        // current iteration counter
        int         iMaxCnt = this.getMaxIterations();  // maximum no of iterations

        double      s = 0.0;                    // location of probe within element
        double      h = this.getStepSize();     // the current step size
        double      L = elem.getLength();       // length of the element
        EnvelopeProbeState stateRef =           // initial state of the probe 
            probe.createProbeState();

        //default temporary commented out 
        double          charge = probe.bunchCharge(); // this doesnt work for PMQ space-charge=0.. why?
        double          hp;             // new step size
        PhaseMatrix     matRes;         // the residual error matrix

//        //sako
//        if (probe.bunchCharge() != 0) {
//            charge = 1;
//        } else if ((elem instanceof IdealDrift) && (((IdealDrift)elem).getCloseElements() != null)) {
//            charge = 1;
//        } else if (elem instanceof IdealPermMagQuad) {
//            charge = 1;
//        } 
//
        do {
            // jdg - if no charge take giant step
            if(charge == 0.) {
                h = L-s; // no space charge - take giant steps
            }
            if (h + s > L) {     // check if we would step outside the element - if so shorten step 
                h = L - s;
            }

            if (getDebugMode()) {
                System.out.println("charge = "+charge);
                System.out.println("EnvTrackerAdapt, elem, probe.getBeamCharge() = "+elem.getId()+" "+probe.bunchCharge());
                System.out.println("going to stepProbeState, h, s, L = "+h+" "+s+" "+L);
            }
            
            // Step the probe according to the algorithm, then compute new step size
            matRes = this.stepProbeState(h, probe, elem);
            // I am actuall not sure with space charge=0, effect of fringe field calc step size can be igonored?
            if(charge == 0.) {
                hp = h;
            } else {
                hp = this.compNewStepSize(h, matRes);

//                if (elem instanceof IdealDrift) {
//                    IdealDrift drift = (IdealDrift)elem;
//                    if (drift.getKDrift()!= 0) {
//
//                        hp     = this.compNewStepSizeDriftPmq(h, matRes);
//                    } else {
//                        hp     = this.compNewStepSize(h, matRes);
//                    }
//                } else {
//                    hp     = this.compNewStepSize(h, matRes);
//                }


            }

            if (hp < h)   {                 // we stepped too far - roll back and try again
                this.rollbackProbe(probe, stateRef);

            } else {                        // our step size meets accuracy critereon - advance probe
                stateRef = probe.createProbeState();
                s       += h;
            }
            h  = hp;            // use the new step size

            if (this.getDebugMode() == true) {        
                if (elem instanceof IdealDrift) {
                    System.out.println("IdealDrift, hp = "+hp);
                }
                System.out.println("propagate s=" + probe.getPosition() + " h=" + h + " hp=" + hp + " N=" + m_nDbgSteps++);
            }

            if (iMaxCnt!=0 && ++iCurCnt >= iMaxCnt)
                throw new ModelException("EnvTrackerAdapt#doPropagation() - maximum iteration count exceeded.");

        } while (s < L);        // do while we are still in the element


        this.setStepSize( h );  // save the last step size as an initial guess for the next time
    }


    /*
     * IContextAware Interface
     */

    /**
     * Load the parameters of this <code>IAlgorithm</code> object from the
     * table data in the given <code>EditContext</code>.  
     * 
     * Here we load only the parameters specific to the base class.  It is expected
     * that Subclasses should override this method to recover the data particular 
     * to there own operation.
     * 
     * @param   strPrimKeyVal   primary key value specifying the name of the data record
     * @param   ecTableData     EditContext containing table data
     * 
     * @see xal.tools.data.IContextAware#load(String, xal.tools.data.EditContext)
     */
    @Override
    public void load(String strPrimKeyVal, EditContext ecTableData) throws DataFormatException {
        super.load(strPrimKeyVal, ecTableData);
         
        // Get the algorithm class name from the EditContext
        DataTable     tblAlgorithm = ecTableData.getTable( EnvTrackerAdapt.TBL_LBL_ENVTRACKERADAPT);
        GenericRecord recTracker = tblAlgorithm.record( Tracker.TBL_PRIM_KEY_NAME,  strPrimKeyVal );

        if ( recTracker == null ) {
            recTracker = tblAlgorithm.record( Tracker.TBL_PRIM_KEY_NAME, "default" );  // just use the default record
        }

        final double errorTolerance = recTracker.doubleValueForKey( ATTRTAG_ERRTOL );
        final double initStep = recTracker.doubleValueForKey( ATTRTAG_INITSTEP );
        final double maxStep = recTracker.doubleValueForKey( ATTRTAG_MAXSTEP );
        final double maxStepDriftPmq = recTracker.doubleValueForKey( ATTRTAG_MAXSTEP_DRIFTPMQ );
        final int norm = recTracker.intValueForKey( ATTRTAG_NORM );
        final int order = recTracker.intValueForKey( ATTRTAG_ORDER );
        final double slack = recTracker.doubleValueForKey( ATTRTAG_SLACK );
        final int maxIter = recTracker.intValueForKey( ATTRTAG_MAXITER );
        
        this.setAccuracyOrder( order );
        this.setMaxIterations( maxIter );
        
        this.setErrorTolerance( errorTolerance );
        this.setInitStepSize( initStep );
        this.setStepSize( initStep );
        this.setMaxStepSize( maxStep );
        this.setMaxStepSizeDriftPmq( maxStepDriftPmq );
        this.setMatrixNorm( norm );
        this.setSlackTolerance( slack );
    }
    
    /*
     * IArchive Interface
     */    

    /** 
     * Load the parameters of the algorithm from a data source exposing the
     * <code>IArchive</code> interface.
     * The superclass <code>load</code> method is called first, then the properties
     * particular to <code>EnvTrackerAdapt</code> are loaded.
     * 
     * @see xal.tools.data.IArchive#load(xal.tools.data.DataAdaptor)
     */
    @Override
    public void load(DataAdaptor daptArchive) throws DataFormatException {
        super.load(daptArchive);
        
        DataAdaptor daptAdapt = daptArchive.childAdaptor(EnvTrackerAdapt.NODETAG_ADAPT);
        if (daptAdapt == null)
            throw new DataFormatException("EnvTrackerAdapt#load() - missing data node " + EnvTrackerAdapt.NODETAG_ADAPT);
            
        if (daptAdapt.hasAttribute(ATTRTAG_ORDER))
            this.setAccuracyOrder( daptAdapt.intValue(ATTRTAG_ORDER) );
        if (daptAdapt.hasAttribute(ATTRTAG_ERRTOL))
            this.setErrorTolerance( daptAdapt.doubleValue(ATTRTAG_ERRTOL) );
        if (daptAdapt.hasAttribute(ATTRTAG_INITSTEP)) {
            this.setStepSize( daptAdapt.doubleValue(ATTRTAG_INITSTEP));
            this.setInitStepSize(daptAdapt.doubleValue(ATTRTAG_INITSTEP));
        }
        if (daptAdapt.hasAttribute(ATTRTAG_MAXSTEP))
            this.setMaxStepSize( daptAdapt.doubleValue(ATTRTAG_MAXSTEP) );
        if (daptAdapt.hasAttribute(ATTRTAG_MAXSTEP_DRIFTPMQ))
            this.setMaxStepSizeDriftPmq( daptAdapt.doubleValue(ATTRTAG_MAXSTEP_DRIFTPMQ) );
        if (daptAdapt.hasAttribute(ATTRTAG_SLACK))
            this.setSlackTolerance( daptAdapt.doubleValue(ATTRTAG_SLACK) );    
        if (daptAdapt.hasAttribute(ATTRTAG_NORM))
            this.setMatrixNorm( daptAdapt.intValue(ATTRTAG_NORM) );
        if (daptAdapt.hasAttribute(ATTRTAG_MAXITER))
            this.setMaxIterations( daptAdapt.intValue(ATTRTAG_MAXITER));
    }

    /**
     * Save the settings particular to this subclass of <code>Tracker</code>.
     * The superclass <code>save</code> method is called first, then the properties
     * particular to <code>EnvTrackerAdapt</code> are saved.
     * 
     * @param   daptArchive     data sink exposing <code>IArchive</code> interface
     * 
     * @see xal.tools.data.IArchive#save(xal.tools.data.DataAdaptor)
     */
    @Override
    public void save(DataAdaptor daptArchive) {
        super.save(daptArchive);
        
        DataAdaptor daptAlg = daptArchive.childAdaptor(Tracker.NODETAG_ALG);
        DataAdaptor daptAdapt = daptAlg.createChild(EnvTrackerAdapt.NODETAG_ADAPT);
        daptAdapt.setValue(ATTRTAG_ORDER, this.getAccuracyOrder());
        daptAdapt.setValue(ATTRTAG_ERRTOL, this.getErrorTolerance());
        daptAdapt.setValue(ATTRTAG_INITSTEP, this.getStepSize());
        daptAdapt.setValue(ATTRTAG_MAXSTEP, this.getMaxStepSize());
        daptAdapt.setValue(ATTRTAG_MAXSTEP_DRIFTPMQ, this.getMaxStepSizeDriftPmq());
        daptAdapt.setValue(ATTRTAG_SLACK, this.getSlackTolerance());
        daptAdapt.setValue(ATTRTAG_NORM, this.getMatrixNorm());
        daptAdapt.setValue(ATTRTAG_MAXITER, this.getMaxIterations());
    }



    /*
     *  Internal Support Functions
     */
     
    /**
     * new stepThinElement by Sako, taken from EnvelopeTracker 
     *  Advances the probe state through a subsection of the element with the
     *  specified length.  Applies a space charge kick at the end of the element
     *  subsection for any probe having nonzero beam current.
     *
     *  @param  ifcElem     interface to the beam element
     *  @param  probe    interface to the probe
     *
     *  @exception ModelException     bad element transfer matrix/corrupt probe state
     */
    protected void stepThinElement(EnvelopeProbe probe, IElement ifcElem)  throws ModelException {

        double dblLen = 0;

        // Get initial conditions of probe
        //       double              gamma = probe.getGamma();
        //       double              K    = probe.beamPerveance();
        PhaseMatrix         res0 = probe.getResponseMatrix();
//        R3                  phs0 = probe.getBetatronPhase();
        //obsolete Twiss [] twissOld = probe.getTwiss();
//        Twiss [] twissOld = probe.getCovariance().computeTwiss();
        CovarianceMatrix   chi0 = probe.getCovariance(); // chi0 = sigma matrix(raw)

        // Get properties of the element
        double      L    = dblLen;
        PhaseMap    mapE = ifcElem.transferMap(probe, L); //first calculate transfer matrix (mapE, PhiE=Phi)
        PhaseMatrix PhiE = mapE.getFirstOrder();  

        PhaseMatrix Phi = PhiE;//transfermap


        PhaseMatrix res1 = Phi.times( res0); // 
        PhaseMatrix chi1 = chi0.conjugateTrans( Phi );  //chi1 = sigma matrix (new)

        //    PhaseMatrix chi1raw = chi0.conjugateTrans( Phi );  //chi1 = sigma matrix (new)

        //sako emittance growth effect for RFGap

        //    CovarianceMatrix cor2 = null;

        if (ifcElem instanceof IdealRfGap) {
            IdealRfGap      gap = (IdealRfGap)ifcElem;
            
            //new 7 Aug 06, Sako
            double sigmaCor[] = this.correctSigmaPhaseSpread(probe, gap); //correction for sigma matrix

            double sigmaCorTrans = sigmaCor[0];
            double sigmaCorLong = sigmaCor[1];

            double s11new = chi1.getElem(1,1)+sigmaCorTrans*chi1.getElem(0,0);
            chi1.setElem(1,1,s11new);
            
            double s33new = chi1.getElem(3,3)+sigmaCorTrans*chi1.getElem(2,2);
            chi1.setElem(3,3,s33new);
            
            double s55new = chi1.getElem(5,5)+sigmaCorLong*chi1.getElem(4,4);
            chi1.setElem(5,5,s55new);


        }

        // Save the new state variables in the probe
        probe.setResponseMatrix(res1);

        //default
        probe.setCovariance(new CovarianceMatrix(chi1));
//        probe.advanceTwiss(Phi, ifcElem.energyGain(probe, dblLen) );//Phi=transferemap

        // phase update:
        //obsolete Twiss [] twissNew = probe.getTwiss();
//        Twiss [] twissNew = probe.getCovariance().computeTwiss();
//        R3  phs1 = phs0.plus( Phi.compPhaseAdvance(twissOld, twissNew) );//Phi=Transferemap
//        probe.setBetatronPhase(phs1);


        this.advanceProbe(probe, ifcElem, 0.0);
    };

    /** 
     * Original code
     * Propagate the probe through a thin element where no space charge effects
     * will occur.
     * 
     * @param probe     probe to propagate
     * @param elem      thin beamline element
     * @throws ModelException   unable to compute transfer matrix for element
     */    
    @SuppressWarnings("unused")
    private void    stepThinElementOrg(EnvelopeProbe probe, IElement elem) throws ModelException {
        PhaseMatrix     matPhi  = this.compElemTransMatrix(0.0, probe, elem);
        PhaseMatrix     matResp = matPhi.times( probe.getResponseMatrix() );
        PhaseMatrix     matChi  = probe.getCovariance().conjugateTrans(matPhi);
        Twiss [] twissOld = probe.getCovariance().computeTwiss();

        probe.setResponseMatrix( matResp );

        //sako emittance growth effect for RFGap
        //see RfGap.f of Trace3D        

        //default
        if (elem instanceof IdealRfGap) {
            IdealRfGap  gap = (IdealRfGap)elem;
            
            double sigmaCorTransOld = this.correctTransSigmaPhaseSpread(probe, gap);
            double sigmaCorLongOld  = this.correctLongSigmaPhaseSpread(probe, gap);

            //new 7 Aug 06, Sako
            double sigmaCor[] = this.correctSigmaPhaseSpread(probe, gap);

            double sigmaCorTrans = sigmaCor[0];
            double sigmaCorLong = sigmaCor[1];

            if (getDebugMode()) {
                System.out.println("sigmaCorTrans, sigmaCorTransOld = "+sigmaCorTrans+" "+sigmaCorTransOld);
                System.out.println("sigmaCorLong, sigmaCorLongOld = "+sigmaCorLong+" "+sigmaCorLongOld);
            }
            double s11new = matChi.getElem(1,1)+sigmaCorTrans*matChi.getElem(0,0);
            matChi.setElem(1,1,s11new);
            double s33new = matChi.getElem(3,3)+sigmaCorTrans*matChi.getElem(2,2);
            matChi.setElem(3,3,s33new);
            double s55new = matChi.getElem(5,5)+sigmaCorLong*matChi.getElem(4,4);
            matChi.setElem(5,5,s55new);

        }

        probe.setCovariance( new CovarianceMatrix(matChi) );

        //sako new (this must be used for correct RFGap implementation!!!)
        /*
        if (elem instanceof IdealRfGap) {

	    CovarianceMatrix matCor = probe.getCorrelation();

	    double sigmaCorTrans = ((IdealRfGap)elem).correctTransSigmaPhaseSpread(probe);
	    double sigmaCorLong  = ((IdealRfGap)elem).correctLongSigmaPhaseSpread(probe);
	    double s11new = matCor.getElem(1,1)+sigmaCorTrans*matCor.getElem(0,0);
	    matCor.setElem(1,1,s11new);
	    double s33new = matCor.getElem(3,3)+sigmaCorTrans*matCor.getElem(2,2);
	    matCor.setElem(3,3,s33new);
	    double s55new = matCor.getElem(5,5)+sigmaCorLong*matCor.getElem(4,4);
	    matCor.setElem(5,5,s55new);

        } else {
        	// System.out.println("not instanceof IdealRfGap");
	}
         */

//        Twiss [] twissNew = probe.getCovariance().computeTwiss();
//        R3 vecPhs  = probe.getBetatronPhase().plus( matPhi.compPhaseAdvance(twissOld, twissNew) );  
//        probe.setBetatronPhase( vecPhs );

        // update the twiss info stored in the probe & state objects
//        probe.advanceTwiss(matPhi, elem.energyGain(probe, 0.));

        this.advanceProbe(probe, elem, 0.0);
    }

    /**
     * <p>
     * Advances the <code>probe</code> a distance <code>h</code> through element
     * <code>elem</code>.  The probe state is determined using two steps of size
     * <i>h</i>/2.  This result is compared to an addition computation where the
     * probe is advance by <i>h</i> using a single step.  The residual matrix is
     * returned as an error criterion.
     * </p>
     * <p>
     * The stepping algorithm includes space charge and is second-order accurate.
     * Using "internal extrapolation" with the residual matrix we can produce an
     * answer that is third-order accurate yet the error criterion is only valid
     * to second order.
     * </p> 
     * 
     * @param h         distance to advance probe
     * @param probe     probe to advance through element
     * @param elem      beamline element acting on probe
     * 
     * @return          residual error matrix from second-order stepping procedure
     * 
     * @throws ModelException   unable to compute the element's transfer matrix
     * 
     * @see #compTransferMatrix
     * @see #advanceProbe
     */
    private PhaseMatrix  stepProbeState(double h, EnvelopeProbe probe, IElement elem) 
        throws ModelException
    {
        // Get the initial state
//        R3                  vecPhs0 = probe.getBetatronPhase();
        PhaseMatrix         matRes0 = probe.getResponseMatrix();
        CovarianceMatrix   matChi0 = probe.getCovariance();
//        Twiss [] twissOld = probe.getCovariance().computeTwiss();
	//obsolete Twiss [] twissOld = probe.getTwiss();
            
        // Compute the reference state matChi1
        PhaseMatrix matPhi1 = this.compTransferMatrix(h, probe, elem);
        PhaseMatrix matChi1 = matChi0.conjugateTrans( matPhi1 ); 
                      
        // Compute the double stepped state while advancing probe
        PhaseMatrix matPhi2 = this.compTransferMatrix(h/2.0, probe, elem);
        
        PhaseMatrix matRes2 = matPhi2.times( matRes0 );
        PhaseMatrix matChi2 = matChi0.conjugateTrans( matPhi2 );

        probe.setResponseMatrix( matRes2 );        
        probe.setCovariance( new CovarianceMatrix(matChi2) );
//        Twiss [] twissNew = probe.getCovariance().computeTwiss();
        //obsolete Twiss [] twissNew = probe.getTwiss();
//        R3 vecPhs2 = vecPhs0.plus( matPhi2.compPhaseAdvance(twissOld, twissNew) );       
//        probe.setBetatronPhase(vecPhs2);

        // update the twiss info stored in the probe & state objects
//        probe.advanceTwiss(matPhi2, elem.energyGain(probe, h/2.0));

        super.advanceProbe(probe, elem, h/2.0);

        matPhi2 = this.compTransferMatrix(h/2.0, probe, elem);

        matRes2 = matPhi2.times( matRes2 );
        matChi2 = matChi2.conjugateTrans( matPhi2 );           

        // Compute the residual matrix and perform internal extrapolation for final state
        PhaseMatrix     matRes = matChi2.minus( matChi1 );

        probe.setResponseMatrix( matRes2 );
        probe.setCovariance( this.compInternExtrap(matRes, matChi2) );

        // update the twiss info stored in the probe & state objects
//        probe.advanceTwiss(matPhi2, elem.energyGain(probe, h/2.));

//        Twiss [] twissNew2 = probe.getCovariance().computeTwiss();
        //obsolete Twiss [] twissNew2 = probe.getTwiss();
//        vecPhs2 = vecPhs2.plus( matPhi2.compPhaseAdvance(twissNew, twissNew2) );
//        probe.setBetatronPhase(vecPhs2);
	
        super.advanceProbe(probe, elem, h/2.0);
	
//	probe.advanceElapsedTime(h);

        return matRes;
    }
     
    /**
     * Rollback the state of the probe to the given reference state.  
     * If the probe update policy is <code>Tracker.UPDATE_ALWAY</code>
     * then we must also eliminate the past two states in the probe's
     * trajectory, which were set by calls to <code>super.advanceProbe
     * </code> in the <code>advanceState</code> method.
     * 
     * @param probe     probe to be rolled back
     * @param stateRef  probe state to reset probe 
     * 
     * @see Tracker#getProbeUpdatePolicy
     * @see Tracker#advanceProbe
     * @see EnvTrackerAdapt#advanceState
     */
    private void    rollbackProbe(EnvelopeProbe probe, EnvelopeProbeState stateRef) {
        probe.applyState(stateRef);
        
        if (this.getProbeUpdatePolicy() == Tracker.UPDATE_ALWAYS)  {
            probe.getTrajectory().popLastState();
            probe.getTrajectory().popLastState();
        }
        
        if (this.getDebugMode() == true)  
            System.out.println("ROLLBACK at s=" + probe.getPosition());
    }

    /**
     * Return the norm of a matrix.  The type of norm used to 
     * calculated the value is given by <code>getMatrixNorm()</code>.
     * 
     * @param mat   matrix for which the norm is calculated
     * 
     * @return      norm of the given matrix
     * 
     * @see         #getMatrixNorm
     */    
    private double  compMatrixNorm(PhaseMatrix mat) {
        
        switch (getMatrixNorm())    {
            
            case EnvTrackerAdapt.NORM_LINF:
            	if (getDebugMode()) {
            		System.out.println("now NORM_LINF");
                	System.out.println("trying to print matrix");
                	System.out.println(mat);
//	            	PrintWriter os = new PrintWriter(System.out);
//                  	mat.print(os);
//                  	os.flush();
                }
                return mat.normInf();
                
            case EnvTrackerAdapt.NORM_L1:
            	if (getDebugMode()) {
            		System.out.println("now NORM_L1");
                    System.out.println(mat);
//	            	PrintWriter os = new PrintWriter(System.out);
//                  	mat.print(os);
//                  	os.flush();
            	}
                   return mat.norm1();
                
            case EnvTrackerAdapt.NORM_L2:
            	if (getDebugMode()) {
            		System.out.println("now NORM_L2");
                    System.out.println(mat);
//            	PrintWriter os = new PrintWriter(System.out);
//                  	mat.print(os);
//                  	os.flush();
            	}
                return mat.norm2();
                
            default:
            	if (getDebugMode()) {
            		System.out.println("now normInf is obtained");
                    System.out.println(mat);
//	            	PrintWriter os = new PrintWriter(System.out);
//                  	mat.print(os);
//                  	os.flush();
            	}
                return mat.normInf();
        }
    }

    /**
     * Computes the transfer matrix for the given <code>IElement</code> for a 
     * distance <i>h</i> for the given <code>IProbe</code> object.
     * 
     * @param h         distance for which transfer matrix is valid (in <b>meters</b>)
     * @param probe     <code>IProbe</code> object for which transfer matrix is computed
     * @param elem      compute transfer matrix for this <code>IElement</code> object
     * 
     * @return          transfer matrix for <code>elem</code>
     * 
     * @throws ModelException   transfer matrix computation error - internal to <code>IElement</code>
     */
    private PhaseMatrix compElemTransMatrix(double h, IProbe probe, IElement elem) 
        throws ModelException   
    {
        // Get transfer map of the element and take first order component
        PhaseMap    mapE    = elem.transferMap(probe, h);
        PhaseMatrix matPhiE = mapE.getFirstOrder();
    
        return matPhiE;
    }



    /*
     * Accuracy Order
     */
     

    /**
     * Compute the new step size from the error residual and the current
     * step size assuming that the stepping algorthim is first-order
     * accurate.  The new step size is determined from the prescribed
     * error tolerance value recovered from <code>#getErrorTolerance()</code>
     * and the norm of the residual (note that the type of norm used
     * is determined by <code>getLebesgueNorm()</code>).
     * 
     * @param  h       current step size
     * @param  matRes  residual error matrix from the stepping
     * 
     * @return     new step size
     * 
     * @see     #getErrorTolerance
     * @see     #getLebesgueNorm
     * @see     #compMatrixNorm
     */
    private double  compNewStepSize(double h, PhaseMatrix matRes)   {

        double      toler = this.getErrorTolerance();
        double      hmax  = this.getMaxStepSize();
        double      slack = this.getSlackTolerance();
        double      error = compMatrixNorm(matRes);

        if (getDebugMode()) {        
            if (Math.abs(h)<1e-5) {
                System.out.println("compNewStepSize, h = 0");
            }

            System.out.println("error = "+error);
            if (Math.abs(error) <1e-5) {
                System.out.println("compNewStepSize, error = 0");
            }
        }

        // Compute the new step size
        double      hnew;       // new step size

        if (this.getAccuracyOrder() == ACCUR_ORDER1)
            hnew  = h*Math.sqrt( toler/error );
        else
            hnew  = h*Math.pow( toler/error, 1.0/3.0 );

        if (hmax!=0.0 && hnew>hmax)
            hnew = hmax;

        else if ( Math.abs( (hnew-h)/h ) < slack )
            hnew = h;

        if (this.getDebugMode() == true) {
            System.out.println("residual error=" + error);
            System.out.println("hnew = "+hnew);
        }
        return hnew;        
    }



    //sako, only for drift with pmq, this is necessary.... 
    /**
     * sako, only for drift with pmq, this is necessary....
     * 
     * @param h
     * @param matRes
     * @return
     *
     * @author Christopher K. Allen
     * @since  Aug 25, 2011
     */
    private double  compNewStepSizeDriftPmq(double h, PhaseMatrix matRes)   {

        double      toler = this.getErrorTolerance();
        double      hmax  = this.getMaxStepSizeDriftPmq();
        double      slack = this.getSlackTolerance();
        double      error = compMatrixNorm(matRes);

        if (this.getDebugMode() == true) {
            if (Math.abs(h)<1e-5) {
                System.out.println("compNewStepSizeDriftPmq, h = 0");
            }
            if (Math.abs(error) <1e-5) {
                System.out.println("compNewStepSizeDriftPmq, error = 0");
            }
        }
        // Compute the new step size
        double      hnew;       // new step size

        if (this.getAccuracyOrder() == ACCUR_ORDER1)
            hnew  = h*Math.sqrt( toler/error );
        else
            hnew  = h*Math.pow( toler/error, 1.0/3.0 );

        if (hmax!=0.0 && hnew>hmax)
            hnew = hmax;

        else if ( Math.abs( (hnew-h)/h ) < slack )
            hnew = h;

        if (this.getDebugMode())
            System.out.println("residual error=" + error);

        return hnew;        
    }
    

    /**
     * Perform an internal extrapolation to generate an estimate of the 
     * probe state (correlation matrix) that is one order higher in 
     * accuracy than the algorithm provides.  Although the estimate might
     * be higer-order accurate this does not guarantee that it is any closer
     * to the real answer.  And we have no way of enforcing any error
     * tolerance.
     *  
     * @param matRes        the residual error matrix from the two half-step/one whole step process 
     * @param matState      the new probe state generated by stepping
     * 
     * @return              an extrapolated value of the probe state
     */
    private CovarianceMatrix   compInternExtrap(PhaseMatrix matRes, PhaseMatrix matState)   {
        PhaseMatrix matChi;     // the extrapolated matrix

        if (this.getAccuracyOrder() == ACCUR_ORDER1)
            matChi = matState.plus( matRes );
        else            
            matChi = matRes.times(1./3.).plus( matState );
            
        return new CovarianceMatrix(matChi);
    }
    
    

    /**
     * Computes the full transfer matrix for a section of length <code>s</code>.  
     * The returned transfer matrix is first-order accurate and includes 
     * both the effects of the <code>IElement</code> and the effects of space charge.
     * 
     * @param   h       distance for which transfer matrix will propagate probe
     * @param   probe   the <code>IProbe</code> object for which the transfer matrix is valid
     * @param   elem    the <code>IElement</code> object
     * 
     * @return  7x7 2nd-order accurate transfer matrix in homogeneous phase space coordinates
     * 
     * @throws  ModelException  unable to compute the transfer matrix for the element
     * 
     * @see #compElemTransMatrix
     * @see #compScheffTransMatrix
     */
    private PhaseMatrix compTransferMatrix(double h, EnvelopeProbe probe, IElement elem) 
        throws ModelException    
    {

        // jdg - bail if no space charge is needed:
        if (probe.bunchCharge() == 0.) return this.compElemTransMatrix(h, probe, elem);

        //        PhaseMatrix matPhiSc = this.compScheffTransMatrixWhenAligned(h, probe);
        PhaseMatrix matPhiSc = super.compScheffMatrix(h, probe, elem);

        // We're going to try something different and ensure symplecticity
        
        // If we are only first-order accurate get the full transfer matrices for the two effects,
        //  multiply them, and return the combined matrix
        if (this.getAccuracyOrder() == ACCUR_ORDER1) {
            PhaseMatrix matPhiE = this.compElemTransMatrix(h, probe, elem);
            PhaseMatrix matPhi  = matPhiE.times(matPhiSc);
            
            return matPhi;
        }

        // Get the transfer matrices for the two individual effects and 
        //  combine them to second-order accuracy (via Campbell-Baker-Hausdorff)
        PhaseMatrix matPhiE = this.compElemTransMatrix(h/2.0, probe, elem);

        // Build the composite transfer matrix up to second order
        PhaseMatrix     matPhi = matPhiSc.times( matPhiE );
        PhaseMatrix     matCom = matPhiE.times( matPhi );

        return matCom;
    }

//    /**
//     * Computes the full transfer matrix for a section of length <code>s</code>.  
//     * The returned transfer matrix is first-order accurate and includes 
//     * both the effects of the <code>IElement</code> and the effects of space charge.
//     * 
//     * @param   h       distance for which transfer matrix will propagate probe
//     * @param   probe   the <code>IProbe</code> object for which the transfer matrix is valid
//     * @param   elem    the <code>IElement</code> object
//     * 
//     * @return  7x7 2nd-order accurate transfer matrix in homogeneous phase space coordinates
//     * 
//     * @throws  ModelException  unable to compute the transfer matrix for the element
//     * 
//     * @see #compElemTransMatrix
//     * @see #compScheffTransMatrix
//     */
//    private PhaseMatrix compTransferMatrix(double h, EnvelopeProbe probe, IElement elem) 
//        throws ModelException    
//    {
//
//        // Get the transfer matrices for the two individual effects
//        PhaseMatrix matPhiE = this.compElemTransMatrix(h, probe, elem);
//        // jdg - bail if no space charge is needed:
//        if (probe.bunchCharge() == 0.) return matPhiE;
//
//        //        PhaseMatrix matPhiSc = this.compScheffTransMatrixWhenAligned(h, probe);
////        PhaseMatrix matPhiSc = this.compScheffTransMatrix(h, probe);
//        PhaseMatrix matPhiSc = super.compScheffMatrix(h, probe, elem);
//
//
//        // Build the composite transfer matrix up to second order
//        PhaseMatrix     matPhi = matPhiSc.times( matPhiE );
//        if (this.getAccuracyOrder() == ACCUR_ORDER1)
//            return matPhi;
//
//        PhaseMatrix     matCom = matPhiE.times( matPhiSc );
//
//        matPhi.plusEquals( matCom );
//        matPhi.timesEquals( 0.5 );
//
//        return matPhi;
//    }
    
//    /**
//     * Computes the linear transfer matrix for space charge effects to
//     * second order in h.  Note that this transfer matrix is valid only 
//     * for the current shape of the beam charge as described by the
//     * <code>CovarianceMatrix</code> in the <code>probe</code> argument.
//     * As the beam propagates the shape changes (due, in part, to the space
//     * charge transfer matrix) and new transfer matrices must be computed.
//     * 
//     * @param h         path length
//     * @param probe     <code>EnvelopeProbe</code> specifying envelope shape
//     * 
//     * @return  linear transfer matrix represented space charge effect to 2nd order
//     */    
//    @SuppressWarnings("unused")
//    private PhaseMatrix compScheffTransMatrix(double h, EnvelopeProbe probe)    {
//
//        // Build transfer matrix generator for space charge effects
//        double              K       = probe.beamPerveance();
//        CovarianceMatrix   matChi   = probe.getCovariance();
//        
//        BeamEllipsoid      rho      = new BeamEllipsoid(K, matChi);
//        PhaseMatrix        matGenSc = rho.computeScheffGenerator(K);
//
////      EllipsoidalCharge   rho    = new EllipsoidalCharge(K, matChi);
////      PhaseMatrix         matGenSc  = rho.compTransMatrixGen();
//
//
//        // jdg - skip if no spacecharge:
//        if (K == 0.) return PhaseMatrix.identity();
//        
//
//        // Debug - display the ellipsoid rotation matrix
//        //        if (this.getDebugMode() == true)    {
//        //            PrintWriter out = new PrintWriter(System.out);
//        //            
//        //            System.out.println("Ellipsoid rotation matrix s=" + this.getElemPosition());
//        //            rho.getRotation().print(out);
//        //            out.flush();
//        //        }
//
//
//        // Build the transfer matrix up to second order in h
//        // We are lucky - due to the structure of the generator matrix all powers >=2 are zero        
//        PhaseMatrix         matPhiSc = PhaseMatrix.identity();
//
//        matPhiSc.plusEquals( matGenSc.times(h) );
//        //        if (this.getAccuracyOrder() == ACCUR_ORDER1)    
//        //            return matPhiSc;
//        //            
//        //        matPhiSc.plusEquals( matGenSc.times(matGenSc).times(0.5*h*h) );
//        return matPhiSc;
//    }
    
    
//    /**
//     * <p>
//     * Computes the space charge transfer matrix for the given length and the given
//     * beam when the beam ellipsoid is aligned to the laboratory coordinate system.
//     * In that case the beam covariance matrix takes a particularly simple form where
//     * the envelope properties can be read off directly.  The space charge calculations
//     * can be expedited in this case due to the easy access of the beam ellipsoid
//     * parameters and the idempotency of the Lie generator matrix for the transfer
//     * matrix.
//     * </p>
//     * <p>
//     * <h4>NOTES:</h4>
//     * &middot; This method was converted from using the deprecated 
//     * <code>EllipsoidalCharge</code> class to the newer <code>BeamEllipsoid</code>
//     * class.  CKA: Aug, 2011.
//     * <br>
//     * &middot; Since then this method has not yet been tested and debugged!
//     * <br>
//     * The functionality has now been incorporated into <code>EnvelopeTrackerBase.CompScheffTransMatri()</code>
//     * </p>
//     *
//     * @param h         distance along beamline (meters)
//     * @param probe     beam probe being propagated
//     * 
//     * @return          The transfer matrix <b>M</b> for space charge effects
//     *
//     * @author Christopher K. Allen
//     * @since  Aug 25, 2011
//     */
//    @SuppressWarnings("unused")
//    private PhaseMatrix compScheffTransMatrixWhenAligned(double h, EnvelopeProbe probe) {
//
//        // Get the probe parameters
//        double              K       = probe.beamPerveance();
//        double             dblGamma = probe.getGamma();
//        CovarianceMatrix   matSigma   = probe.getCovariance();
//        
//        // Build the displacement vector
//        double  xm = matSigma.getMeanX();
//        double  ym = matSigma.getMeanY();
//        double  zm = matSigma.getMeanZ();
//        
//        R3      vecDispl = new R3(xm, ym, zm);
//        
//        
//        // Get the semi-axes
// //       double  covXX = matChi.getCovXX();
// //       double  covYY = matChi.getCovYY();
// //       double  covZZ = matChi.getCovZZ();
//        
//        double a = matSigma.getSigmaX();
//        double b = matSigma.getSigmaY();
//        double c = matSigma.getSigmaZ();
//        
//        R3  vecSig = new R3(a, b, c);
//        
//        
//        // Build charge aligned to beam coordinate system
////        EllipsoidalCharge   rho    = new EllipsoidalCharge(K, a, b, c);
////        rho.setDisplacement(vecDispl);
//        
//        BeamEllipsoid       rho = new BeamEllipsoid(dblGamma, vecDispl, vecSig.squared());
//        
//        // Build the transfer matrix up to second order in h
//        // We are lucky - due to the structure of the generator matrix all powers >=2 are zero        
//        PhaseMatrix         matGenSc = rho.computeScheffGenerator(K);
//        PhaseMatrix         matPhiSc = PhaseMatrix.identity();
//        
//        matPhiSc.plusEquals( matGenSc.times(h) );
//
//        return matPhiSc;
//        
//    }


}



/*
 *  Storage
 */
 
 
 
///**
//* Override the <code>Tracker</code> implementation to support saving
//* the probe trajectory information.
//* 
//* @param   probe       probe to advance
//* @param   elem        beamline element to advance probe through
//* @param   dblLen      distance to advance probe
//* 
//* @throws  ModelException  this should not occur
//*/
//protected void advanceProbe(IProbe probe, IElement elem, double dblLen)
//  throws ModelException 
//{
//  m_cntUpdate++;
//  System.out.println("advanceProbe() " + m_cntUpdate);
//
//  super.advanceProbe(probe, elem, dblLen);
//}
//
//

 
 
