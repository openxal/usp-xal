//
//  KnobGroup.java
//  xal
//
//  Created by Thomas Pelaia on 10/31/05.
//  Copyright 2005 Oak Ridge National Lab. All rights reserved.
//

package xal.app.knobs;

import xal.tools.messaging.MessageCenter;
import xal.tools.data.*;

import java.util.*;


/** Group of knobs */
public class KnobGroup implements Comparable<KnobGroup>, DataListener, KnobListener {
	/** The DataAdaptor label */
	static public final String DATA_LABEL = "KnobGroup"; 
	
	/** The message center for this group's originated events */
	protected final MessageCenter MESSAGE_CENTER;
	
	/** The proxy for posting KnobGroupListener events */
	protected final KnobGroupListener EVENT_PROXY;
	
	/** The list of knobs in this group */
	final protected List<Knob> _knobs;
	
	/** The label for this group */
	protected String _label;
	
	
	/**
	 * Constructor
	 * @param label The label for the group
	 */
	public KnobGroup( final String label ) {
		this( label, new Vector<Knob>() );
	}
	
	
	/**
	 * Primary constructor
	 * @param label The label for the group
	 * @param knobs The initial list of knobs to include in the group
	 */
	public KnobGroup( final String label, final List<Knob> knobs ) {
		MESSAGE_CENTER = new MessageCenter( DATA_LABEL );
		EVENT_PROXY = MESSAGE_CENTER.registerSource( this, KnobGroupListener.class );
		
		_label = label;
		_knobs = new ArrayList<Knob>( knobs );
	}
    
    
    /** 
	* dataLabel() provides the name used to identify the class in an external data source.
	* @return The tag for this data node.
	*/
    public String dataLabel() {
        return DATA_LABEL;
    }
    
    
    /**
	 * Instructs the receiver to update its data based on the given adaptor.
     * @param adaptor The data adaptor corresponding to this object's data node.
     */
    public void update( final DataAdaptor adaptor ) {
    }
    
    
    /**
	 * Instructs the receiver to write its data to the adaptor for external storage.
     * @param adaptor The data adaptor corresponding to this object's data node.
     */
    public void write( final DataAdaptor adaptor ) {
		adaptor.setValue( "label", _label );
		
		for ( Knob knob : _knobs ) {
			final DataAdaptor knobAdaptor = adaptor.createChild( "KnobRef" );
			knobAdaptor.setValue( "knobID", knob.getID() );
		}
    }
	
	
	/**
	 * Add a listener of KnobGroupListener events generated by this AppGroup
	 * @param listener The listener to add
	 */
	public void addKnobGroupListener( final KnobGroupListener listener ) {
		MESSAGE_CENTER.registerTarget( listener, this, KnobGroupListener.class );
	}
	
	
	/**
	 * Remove a listener of KnobGroupListener events generated by this AppGroup
	 * @param listener The listener to remove
	 */
	public void removeKnobGroupListener( final KnobGroupListener listener ) {
		MESSAGE_CENTER.removeTarget( listener, this, KnobGroupListener.class );
	}
	
	
	/**
	 * Get the label for this group
	 * @return this group's label
	 */
	public String getLabel() {
		return _label;
	}
	
	
	/**
	 * Set the label for this group
	 * @param label The new label for this group
	 */
	public void setLabel( final String label ) {
		_label = label;
		EVENT_PROXY.labelChanged( this );
	}
	
	
	/**
	 * Determine if the group allows editing of its label
	 * @return true
	 */
	public boolean allowsLabelEdit() {
		return true;
	}
	
	
	/**
	 * Get the knob at the specified index
	 * @param index The index of the knob to get
	 * @return The knob at the index in this group's list
	 */
	public Knob getKnob( final int index ) {
		return _knobs.get( index );
	}
	
	
	/**
	 * Get the list of this group's applications
	 * @return The list of this group's applications
	 */
	public List<Knob> getKnobs() {
		return _knobs;
	}
	
	
	/**
	 * Get the count of knobs in this group
	 * @return the count of knobs in this group
	 */
	public int getKnobCount() {
		return _knobs.size();
	}
	
	
	/**
	 * Determine if this group contains the specified knob
	 * @param knob The knob for which to check
	 * @return true if this group contains the knob and false if not
	 */
	public boolean contains( final Knob knob ) {
		return _knobs.contains( knob );
	}
	
	
	/**
	 * Add the collection of knobs to this group and notify listeners
	 * @param knobs The collection of knobs to add
	 */
	public void addKnobs( final Collection<Knob> knobs ) {
		synchronized( _knobs ) {
			for ( Knob knob : knobs ) {
				addKnobWithoutSorting( knob );
			}
			sortKnobs();
		}
		EVENT_PROXY.knobsAdded( this, knobs );
	}
	
	
	/**
	 * Add a knob to this group and notify listeners
	 * @param knob The knob to add
	 */
	public void addKnob( final Knob knob ) {
		boolean shouldPost = false;
		synchronized( _knobs ) {
			if ( !contains( knob ) ) {
				addKnobWithoutSorting( knob );
				sortKnobs();
				shouldPost = true;
			}
		}
		if ( shouldPost ) {
			EVENT_PROXY.knobsAdded( this, Collections.singleton( knob ) );
		}
	}
	
	
	/**
	 * Add a knob without sorting or event handling.
	 * @param knob the knob to add
	 */
	private void addKnobWithoutSorting( final Knob knob ) {
		synchronized( _knobs ) {
			if ( !contains( knob ) ) {
				_knobs.add( knob );
				knob.addKnobListener( this );
			}
		}
	}
	
	
	/**
	 * Remove the specified knob from this group and notify listeners
	 * @param knobs The knobs to remove
	 */
	public void removeKnobs( final List<Knob> knobs ) {
		synchronized( _knobs ) {
			for ( Knob knob : knobs ) {
				if ( contains( knob ) ) {
					knob.removeKnobListener( this );
					_knobs.remove( knob );
				}
			}
			sortKnobs();
		}
		EVENT_PROXY.knobsRemoved( this, knobs );
	}
	
	
	/**
	 * Remove the specified knob from this group and notify listeners
	 * @param knob The knob to remove
	 */
	public void removeKnob( final Knob knob ) {
		synchronized( _knobs ) {
			if ( contains( knob ) ) {
				removeKnobs( Collections.singletonList( knob ) );
			}
		}
	}
	
	
	/**
	 * Provide a string representation of the group.
	 * @return the group's label
	 * @see #getLabel
	 */
	public String toString() {
		return getLabel();
	}
	
	
	/** Sort the knobs alphabetically */
	synchronized protected void sortKnobs() {
		Collections.sort( _knobs );
	}
	
	
	/**
	 * Compare two instances.  The two instances are compared by label and the comparison is based on alphebetical sorting.
	 * @param group the other object against which to compare this one
	 * @return a positive number if this comes after the argument, negative if this comes before and 0 if they are equal
	 * @see #getLabel
	 */
	public int compareTo( final KnobGroup group ) {
		return _label.compareToIgnoreCase( group._label );
	}
	
	
	/** event indicating that the specified knob's name has changed */
	public void nameChanged( final Knob knob, final String newName ) {
		sortKnobs();
		EVENT_PROXY.knobModified( this, knob );
	}
	
	
	/** ready state changed */
	public void readyStateChanged( final Knob knob, final boolean isReady ) {}
	
	
	/** event indicating that the knob's limits have changed */
	public void limitsChanged( final Knob knob, final double lowerLimit, final double upperLimit ) {}
	
	
	/** event indicating that the knob's current value setting has changed */
	public void currentSettingChanged( final Knob knob, final double value ) {}
	
	
	/** event indicating that the knob's most previously pending set operation has completed */
	public void valueSettingPublished( final Knob knob ) {}
	
	
	/** event indicating that an element has been added */
	public void elementAdded( final Knob knob, final KnobElement element ) {
		EVENT_PROXY.knobModified( this, knob );
	}
	
	
	/** event indicating that an element has been removed */
	public void elementRemoved( final Knob knob, final KnobElement element ) {
		EVENT_PROXY.knobModified( this, knob );
	}
	
	
	/** event indicating that the specified knob element has been modified */
	public void elementModified( final Knob knob, final KnobElement element ) {
		EVENT_PROXY.knobModified( this, knob );
	}
}
