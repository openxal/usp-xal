#!/usr/bin/env jruby
#
#  scan1d_scatter_plot.rb
#  Display a scatter plot of selected data sets generated by Scan ID
#
#  Created by Tom Pelaia on 11/26/07.
#  Copyright (c) 2007 SNS. All rights reserved.
#
include Java

import java.awt.Color
import java.io.FileWriter
import java.lang.StringBuffer
import java.lang.System
import java.net.URL
import javax.swing.JFileChooser
import javax.swing.JFrame
import javax.swing.JOptionPane
import javax.swing.SpinnerNumberModel

java_import 'xal.extension.widgets.apputils.SimpleChartPopupMenu'
java_import 'xal.extension.widgets.plot.FunctionGraphsJPanel'
java_import 'xal.extension.widgets.plot.BasicGraphData'
java_import 'xal.extension.bricks.WindowReference'
java_import 'xal.tools.statistics.MutableUnivariateStatistics'
java_import 'xal.tools.math.DiscreteFourierTransform'
java_import 'xal.smf.impl.BPM'
java_import 'xal.smf.data.XMLDataManager'
java_import 'xal.smf.TimingCenter'
java_import 'xal.ca.ConnectionListener'
java_import 'xal.ca.Channel'
java_import 'xal.ca.IEventSinkValTime'
java_import 'xal.ca.Monitor'
java_import 'xal.tools.apputils.ImageCaptureManager'
java_import 'xal.extension.fit.DampedSinusoidFit'
java_import 'xal.extension.application.XalDocument'
java_import 'xal.tools.apputils.files.RecentFileTracker'
java_import 'xal.tools.apputils.files.DefaultFolderAccessory'

module Java
	java_import 'java.lang.reflect.Array'
	java_import 'java.lang.Class'
	java_import 'java.lang.Double'
	java_import 'java.io.File'
	java_import 'java.util.List'
	java_import 'java.lang.Math'
	java_import 'java.util.ArrayList'
	java_import 'java.util.Vector'
	java_import 'java.text.DecimalFormat'
	java_import 'javax.swing.filechooser.FileFilter'
	java_import 'javax.swing.ButtonGroup'
end



# model of functions to resolve Java ambiguities
module JavaResolver
	# Construct a SpinnerNumberModel using integer parameters (addresses ambiguous Java constructor)
	def new_spinner_number_model( value, minimum, maximum, step )
		constructor = SpinnerNumberModel.java_class.constructor( Java::int, Java::int, Java::int, Java::int )
		return constructor.new_instance( value, minimum, maximum, step )
	end
end

include JavaResolver



# extend DecimalFormat to address ambiguity in format()
class DecimalFormat
	java_alias :format_double, :format, [Java::double]
end



class ProfileData
	attr_reader :variables
	attr_reader :position_records
	attr_reader :file_path
	
	def initialize( file_name )
		@file_path = file_name
		
		@lines = IO.readlines( file_name )
		
		load_variables
		load_position_records
	end
	
	def record_count
		return @position_records.length
	end
	
	def load_variables
		var_lines = @lines.find_all{ |line| line =~ /^% data/ }
		@variables = var_lines.collect { |line| BeamPositionVariable.new( line ) }
	end
	
	def load_position_records
		position_lines = @lines.find_all{ |line| line =~ /^\s*-?\d+/ }
		@position_records = position_lines.collect { |line| BeamPositionRecord.parse( line ) }
	end
	
	def writeHeaderTo writer
		# find the header lines and simply write them out verbatim
		header_lines = @lines.find_all{ |line| line =~ /^% / }
		header_lines.each { |line| writer.write( line ) }
	end
end



class BeamPositionVariable
	attr_reader :index
	attr_reader :name
	
	def initialize( line )
		variable_match = /.+data\s+\p{Punct}\s+(\d+)\s+.+yPV=(.+)/.match( line )
		@index = variable_match[1].to_i
		@name = variable_match[2]
	end
	
	def to_s
		return "index: #{@index}, name: #{@name}"
	end
end


class BeamPositionRecord
	attr_reader :delay
	attr_reader :positions
	
	
	def initialize( delay, positions )
		@delay = delay
		@positions = positions
	end
	
	
	def self.parse( line )
		items = line.split
		delay = items[0].to_f
		positions = items[1..-1].collect{ |item| item.to_f }
		return BeamPositionRecord.new( delay, positions )
	end
	
	def writeTo writer
		buffer = StringBuffer.new
		buffer.append @delay
		@positions.each { |position|
			buffer.append( " " )
			buffer.append( position )
		}
		buffer.append( "\n" )
		writer.write( buffer.toString )
	end
end



class ProfileAnalyzer
	attr_reader :profile_data
	attr_accessor :lower_index
	attr_accessor :upper_index
	
	def initialize( the_profile_data )
		@profile_data = the_profile_data
		reset_range
	end
	
	def reset_range
		@lower_index = 0
		@upper_index = @profile_data.record_count - 1
	end
	
	def records
		if @lower_index >= 0 and @upper_index >= @lower_index
			return @profile_data.position_records[ @lower_index..@upper_index ]
		else
			return Array.new
		end
	end
	
	def run( x_index, y_index )
		return ProfileAnalysis.new( self.records, x_index, y_index )
	end
	
	def centeredRecords
		selected_records = self.records
		if selected_records.length > 0
			centers = Array.new
			@profile_data.variables.each_index { |var_index|
				center = ProfilePlaneAnalysis.new( selected_records, var_index ).mean
				centers.push center
			}
			centered_records = selected_records.collect { |record| 
				positions = Array.new
				record.positions.each_with_index { |position, var_index|
					positions.push( position - centers[var_index] )
				}
				BeamPositionRecord.new( record.delay, positions )
			}
			return centered_records
		else
			return []
		end
	end
	
	
	def writeCenteredRecordsTo writer
		self.centeredRecords.each { |record| record.writeTo writer }
	end
end



class ProfileAnalysis
	attr_reader :x_analysis
	attr_reader :y_analysis
	
	def initialize( records, x_index, y_index )
		@x_analysis = ProfilePlaneAnalysis.new( records, x_index )
		@y_analysis = ProfilePlaneAnalysis.new( records, y_index )
	end
	
	def centroid
		return [@x_analysis.mean, @y_analysis.mean]
	end
	
	def standardDeviation
		return [@x_analysis.standardDeviation, @y_analysis.standardDeviation]
	end
end



class ProfilePlaneAnalysis
	attr_reader :statistics
	
	def initialize( records, plane_index )
		@statistics = MutableUnivariateStatistics.new
		records.each { |record| @statistics.addSample( record.positions[plane_index] ) }
	end
	
	def mean
		return statistics.mean
	end
	
	def standardDeviation
		return statistics.standardDeviation
	end
end



class ControlApp
	include javax.swing.event.ChangeListener
	include java.awt.event.ActionListener
	
	attr_reader :main_window
	attr_reader :profile_analyzer
	attr_reader :file_chooser
	
	def initialize window_reference
		@window_reference = window_reference
		
		@main_window = window_reference.getWindow
		
		@x_select_list = @window_reference.getView( "X SelectionList" )
		@y_select_list = @window_reference.getView( "Y Selection List" )
		@scatter_plot = window_reference.getView( "ScatterPlot" )
		SimpleChartPopupMenu.addPopupMenuTo @scatter_plot
		
		@range_checkbox = @window_reference.getView( "RangeCheckBox" )
		@lower_range_spinner = @window_reference.getView( "LowerRangeSpinner" )
		@upper_range_spinner = @window_reference.getView( "UpperRangeSpinner" )
		
		@range_checkbox.addActionListener( self )
		
		@lower_range_spinner.setModel( new_spinner_number_model( 0, 0, 0, 1 ) )
		@lower_range_spinner.addChangeListener( self )
		@upper_range_spinner.setModel( new_spinner_number_model( 0, 0, 0, 1 ) )
		@upper_range_spinner.addChangeListener( self )
		
		@scatter_radio_button = window_reference.getView( "ScatterRadioButton" )
		@spectrum_radio_button = window_reference.getView( "SpectrumRadioButton" )
		plot_style_group = Java::ButtonGroup.new
		plot_style_group.add( @scatter_radio_button )
		plot_style_group.add( @spectrum_radio_button )
		@scatter_radio_button.addActionListener( self )
		@spectrum_radio_button.addActionListener( self )
		
		PlaneDataSelectListener.new( @x_select_list, self )
		PlaneDataSelectListener.new( @y_select_list, self )
		
		self.make_file_chooser

		open_button = window_reference.getView( "OpenButton" )
		OpenButtonHandler.new( open_button, self )

		export_button = window_reference.getView( "ExportButton" )
		ExportButtonHandler.new( export_button, self )

		SnapshotHandler.new( window_reference )
	end
	
	def make_file_chooser
		@file_chooser = JFileChooser.new
		@file_chooser.setFileSelectionMode( JFileChooser::FILES_ONLY )
		@file_chooser.setMultiSelectionEnabled false
		
		# use the XAL document root as the default folder and use the XAL file chooser accessory
		defaultFolderAccessory = DefaultFolderAccessory.new( XalDocument.java_class, nil, "Scan1D" )
		defaultFolderAccessory.applyTo( @file_chooser )
		
		type_filter = FileTypeFilter.new
		type_filter.addType "txt"
		@file_chooser.setFileFilter type_filter
	end
	
	def actionPerformed( event )
		if event.source == @range_checkbox
			use_range = @range_checkbox.isSelected
			@lower_range_spinner.setEnabled( use_range )
			@upper_range_spinner.setEnabled( use_range )
			if use_range
				apply_range
			else
				@profile_analyzer.reset_range
			end
			self.refreshDisplay
		elsif event.source == @scatter_radio_button or event.source == @spectrum_radio_button
			self.refreshDisplay
		end
	end
	
	def stateChanged( event )
		if ( @range_checkbox.isSelected )
			apply_range
			self.refreshDisplay
		end
	end
		
	def apply_range
		lower_index = @lower_range_spinner.getModel.getNumber.to_i
		upper_index = @upper_range_spinner.getModel.getNumber.to_i
		if ( upper_index < lower_index )
			upper_index = lower_index
			@upper_range_spinner.getModel.setValue( upper_index.to_i )
		end
		@profile_analyzer.lower_index = lower_index
		@profile_analyzer.upper_index = upper_index
	end
	
	def displayWindow
		@main_window.setDefaultCloseOperation( JFrame::EXIT_ON_CLOSE )
		@main_window.setVisible( true )
	end
	
	def setProfileDataPath file_path
		@profile_data = ProfileData.new file_path
		@profile_analyzer = ProfileAnalyzer.new @profile_data
		
		variables = @profile_data.variables
		variable_name_vector = Java::Vector.new
		for variable in variables
			variable_name_vector.addElement variable.name
		end
		@x_select_list.setListData( variable_name_vector )
		@y_select_list.setListData( variable_name_vector )		
		
		@profile_analyzer.reset_range
		num_records = @profile_data.record_count
		puts "Found: #{num_records} records."

		lower_index = 0
		upper_index = num_records - 1
		if num_records > 0
			@lower_range_spinner.setModel( new_spinner_number_model( 0, 0, upper_index, 1 ) )
			@upper_range_spinner.setModel( new_spinner_number_model( upper_index, 0, upper_index, 1 ) )
		end
		
		self.clearAnalysis
	end
	
	
	def exportCenteredTo file
		if @profile_data != nil
			puts "exporting centered data to:  #{file.toString}"
			writer = FileWriter.new( file )
			
			@profile_data.writeHeaderTo writer
			@profile_analyzer.writeCenteredRecordsTo writer
			
			writer.flush
			writer.close
		else
			JOptionPane.showMessageDialog( @main_window, "No data to write.", "Nothing to write", JOptionPane::WARNING_MESSAGE )
		end
	end
	
	
	def refreshDisplay
		x_index = @x_select_list.getSelectedIndex
		y_index = @y_select_list.getSelectedIndex
		
		if @scatter_radio_button.isSelected and x_index >= 0 and y_index >= 0
			self.plotProfile( x_index, y_index )
			self.performAnalysis( x_index, y_index )
		elsif @spectrum_radio_button.isSelected and x_index >= 0 and y_index >= 0
			self.plotSpectrum( x_index, y_index )
		end
	end
	
	
	def performAnalysis( x_index, y_index )
		analysis = @profile_analyzer.run( x_index, y_index )		
		displayCentroid( analysis.centroid[0], analysis.centroid[1] )
		displayRMSSize( analysis.standardDeviation[0], analysis.standardDeviation[1] )
	end
	
	
	def clearAnalysis
		displayCentroid( 0.0, 0.0 )
		displayRMSSize( 0.0, 0.0 )
		clearScatterPlot
	end
	
	
	def displayCentroid( x, y )
		formatter = Java::DecimalFormat.new "0.000E0"
		x_center_field = @window_reference.getView( "X_CenterField" )
		y_center_field = @window_reference.getView( "Y_CenterField" )
		x_center_field.setText( formatter.format_double( x ) )
		y_center_field.setText( formatter.format_double( y ) )
	end
	
	
	def displayRMSSize( width, height )
		formatter = Java::DecimalFormat.new "0.000E0"
		rms_width_field = @window_reference.getView( "RMS_WidthField" )
		rms_height_field = @window_reference.getView( "RMS_HeightField" )
		rms_width_field.setText( formatter.format_double( width ) )
		rms_height_field.setText( formatter.format_double( height ) )
	end
	
	
	def clearScatterPlot
		@scatter_plot.removeAllGraphData
		@scatter_plot.setName( "" )
	end

	
	def plotProfile( x_index, y_index )
		x_label = @profile_data.variables[x_index].name
		y_label = @profile_data.variables[y_index].name
		title = @profile_data.file_path
		
		@scatter_plot.removeAllGraphData
		
		@scatter_plot.setGridLineColor( Color::LIGHT_GRAY )
		@scatter_plot.setAxisNameX( x_label )
		@scatter_plot.setAxisNameY( y_label )
		@scatter_plot.setName( title )
		@scatter_plot.setLegendVisible( false )
		
		graph_data = BasicGraphData.new
		graph_data.setDrawLinesOn( false )
		graph_data.setGraphColor( Color::BLUE )
		
		records = @profile_analyzer.records
		records.each { |record| graph_data.addPoint( record.positions[x_index], record.positions[y_index] ) }
		@scatter_plot.addGraphData( graph_data )
	end
	
	
	def plotSpectrum( x_index, y_index )
		title = @profile_data.file_path
		
		@scatter_plot.removeAllGraphData
		
		@scatter_plot.setGridLineColor( Color::LIGHT_GRAY )
		@scatter_plot.setAxisNameX( "Frequency" )
		@scatter_plot.setAxisNameY( "Discrete Fourier Amplitude" )
		@scatter_plot.setName( title )
		@scatter_plot.setLegendVisible( true )

		plotSpectrumForRecord( x_index, Color::RED )
		plotSpectrumForRecord( y_index, Color::GREEN.darker() )
	end
	
	
	def plotSpectrumForRecord( recordIndex, color )
		graph_data = BasicGraphData.new
		graph_data.setGraphProperty( @scatter_plot.getLegendKeyString(), @profile_data.variables[recordIndex].name )
		graph_data.setDrawLinesOn( true )
		graph_data.setGraphColor( color )
		
		all_records = @profile_analyzer.records
		total_count = all_records.size
		if total_count >= 2
			num_points = 2 * ( total_count / 2 )
			records = all_records.slice( 0, num_points )
			points = Java::Array.newInstance( Java::Double::TYPE, num_points )
			records.each_with_index { |record, index|
				Java::Array.setDouble( points, index, record.positions[recordIndex] )
			}
			period = num_points
			transform = DiscreteFourierTransform.new( points, period )
			spectrum = transform.getSpectrum
			spectrum.each_with_index { |fourier_coefficient, index|
				frequency = transform.getFrequency( index )
				graph_data.addPoint( frequency, fourier_coefficient.modulus )
			}
		end
		@scatter_plot.addGraphData( graph_data )
	end
end



class PlaneDataSelectListener
	include javax.swing.event.ListSelectionListener
	
	def initialize( list, controller )
		@list = list
		@controller = controller
		
		@list.addListSelectionListener self
	end
	
	def valueChanged event
		if not event.getValueIsAdjusting
			@controller.refreshDisplay
		end
	end
end



class FileTypeFilter < Java::FileFilter
	def initialize
		@types = Array.new
	end
	
	def addType( type )
		@types.push type
	end
	
	def accept( file )
		name = file.getName
		@types.each { |type|
			pattern = Regexp.new '.*\\.' + type
			if file.isDirectory or name =~ pattern
				return true
			end
		}
		return false
	end
	
	def getDescription
		return "Scan1D ASCII data"
	end
end



class OpenButtonHandler
	include java.awt.event.ActionListener
	
	def initialize( button, controller )
		@controller = controller
		button.addActionListener self
	end
	
	def actionPerformed event
		window = @controller.main_window
		file_chooser = @controller.file_chooser
		status = file_chooser.showOpenDialog( window )
		if status == JFileChooser::APPROVE_OPTION
			file = file_chooser.getSelectedFile
			file_path = file.getAbsolutePath
			@controller.setProfileDataPath file_path
		end
	end
end



class SnapshotHandler
	include java.awt.event.ActionListener
	
	def initialize( window_reference )
		@window = window_reference.getWindow()
		snapshot_button = window_reference.getView( "SnapshotButton" )
		snapshot_button.addActionListener( self )
	end
	
	def actionPerformed( event )
		now = Time.new
		filename = "scan1d_scatter_plot_" + now.strftime( "%Y%m%dT%H%M%S" ) 
		ImageCaptureManager.defaultManager().saveSnapshot( @window.getContentPane, filename )
	end
end



class ExportButtonHandler
	include java.awt.event.ActionListener
	
	def initialize( button, controller )
		@controller = controller
		button.addActionListener self
	end
	
	
	def requestFile
		window = @controller.main_window
		file_chooser = @controller.file_chooser
		status = file_chooser.showSaveDialog( window )
		if status == JFileChooser::APPROVE_OPTION
			file = file_chooser.getSelectedFile
			if file.exists
				proceed_status = JOptionPane.showOptionDialog( @controller.main_window, "Warning, #{file.toString} Exists! \nDo you want to overwrite this file?", "Existing File", JOptionPane::YES_NO_CANCEL_OPTION, JOptionPane::WARNING_MESSAGE, nil, nil, nil )
				if proceed_status == JOptionPane::CLOSED_OPTION or proceed_status == JOptionPane::CANCEL_OPTION
					return nil
				elsif proceed_status == JOptionPane::NO_OPTION
					return requestFile
				end
			end
			return file
		end
		return nil
	end
	
	
	def actionPerformed event
		file = self.requestFile
		if file != nil
			puts "Exporting data to #{file.getAbsolutePath}"
			@controller.exportCenteredTo file
		end
	end
end


# load the user interface
def load_user_interface()
	# locate the enclosing folder and get the bricks file within it
	folder = File.dirname( $0 )
	gui_path = File.join( folder, "gui.bricks" )
	url = Java::File.new( gui_path ).toURI.toURL
	
	# generate a window reference resource and pass the desired constructor arguments
	window_reference = WindowReference::getDefaultInstance( url, "MainWindow" )
	
	main_controller = ControlApp.new window_reference
	main_controller.displayWindow
end


load_user_interface
